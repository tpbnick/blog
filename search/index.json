[{"content":"The Problem We are given 7 numbers that are linked to a number in the alphabet (1=A, 2=B\u0026hellip;26=Z). We must then use those 7 numbers to find an english word that fits the clue. Each number, however, is linked to that letter in the alphabet, plus the next 4 letters. This gives us n+4 combinations for the number given. For example, if we are given the number 1, this could be A, B, C, D, E, or F. We then must find the cartesian product of all possible combinations of letters. We must use the 7 numbers given find a single 7 letter word that fits a clue.\nFor this example, let\u0026rsquo;s use the following puzzle parameters:\n   Clue Past tense noise of an animal     Numbers [16, 20, 1, 2, 9, 3, 4]    The cartesian product can be illustrated as follows (only for 2 sets of 3 possibilities): We will need to create a Python program that gives the cartesian products of (n+4)x7 possibilities. We will then run all combinations against a English dictionary to find any matches to english words.\nFinding Python Libraries First, we need to find a library that will create a list of all possible combinations of letters. After some research, I found the product() iterator in the itertools library.\nThe nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the inputâ€™s iterables are sorted, the product tuples are emitted in sorted order.\nWe also need to use the slice() tool from the more-itertools library. This will yield slices of length n from the sequence seq. For example:\n\u0026gt;\u0026gt;\u0026gt; list(sliced((1, 2, 3, 4, 5, 6), 3))\r[(1, 2, 3), (4, 5, 6)]\r Notice how we have a list of 6 individual numbers that we then set the slice() to be slices of 3 in length.\nNext, we will need to check all strings in the list, generated by the product() iterator, against an English dictionary. Pyenchant is a spellchecking library for Python, based on the excellent Enchant library. We can simply check all strings against the Pyenchant library, using d.check(\u0026quot;word\u0026quot;), which will either give us a response of True or False.\nBuilding the Program First, we must import all of the libraries we will be using.\nimport itertools\rfrom itertools import *\rfrom more_itertools import *\rimport enchant\rd = enchant.Dict(\u0026quot;en_US\u0026quot;)\rimport math\r Here we import itertools, more_itertools, enchant, we swet the enchant dictionary to english (\u0026ldquo;en_US\u0026rdquo;), and math.\nWe will then ask for the seven numbers and store them in a list. We will also set limitations on what numbers can be given. 0-26 are the only numbers we will accept. The integers will then be linked to a dictionary of number-letter pairs.\nletters = []\rmaxLength = 7\rwhile len(letters) \u0026lt; maxLength:\rletter = int(input(\u0026quot;Please input number: \u0026quot;))\rif letter \u0026lt; 0 or letter \u0026gt; 26:\rprint(\u0026quot;Invalid number!\u0026quot;)\rbreak\rletters.append(letter)\rprint(letters)\rletterOne = letters[0]\rletterTwo = letters[1]\rletterThree = letters[2]\rletterFour = letters[3]\rletterFive = letters[4]\rletterSix = letters[5]\rletterSeven = letters[6]\rletterNumber = {\r0 : \u0026quot;/abcd\u0026quot;,\r1 : \u0026quot;abcde\u0026quot;, 2 : \u0026quot;bcdef\u0026quot;, 3 : \u0026quot;cdefg\u0026quot;,\r4 : \u0026quot;defgh\u0026quot;,\r5 : \u0026quot;efghi\u0026quot;,\r6 : \u0026quot;fghij\u0026quot;,\r7 : \u0026quot;ghijk\u0026quot;,\r8 : \u0026quot;hijkl\u0026quot;,\r9 : \u0026quot;ijklm\u0026quot;,\r10 : \u0026quot;jklmn\u0026quot;,\r11 : \u0026quot;klmno\u0026quot;,\r12 : \u0026quot;lmnop\u0026quot;,\r13 : \u0026quot;mnopq\u0026quot;,\r14 : \u0026quot;nopqr\u0026quot;,\r15 : \u0026quot;opqrs\u0026quot;,\r16 : \u0026quot;pqrst\u0026quot;,\r17 : \u0026quot;qrstu\u0026quot;,\r18 : \u0026quot;rstuv\u0026quot;,\r19 : \u0026quot;stuvw\u0026quot;,\r20 : \u0026quot;tuvwx\u0026quot;,\r21 : \u0026quot;uvwxy\u0026quot;,\r22 : \u0026quot;vwxyz\u0026quot;,\r23 : \u0026quot;wxyzz\u0026quot;,\r24 : \u0026quot;xyzzz\u0026quot;,\r25 : \u0026quot;yzzzz\u0026quot;,\r26 : \u0026quot;zzzzz\u0026quot;\r}\r Using the above code we link the first integer given to a string of letters. If we are looking at the numbers given at the top with the clue: [16, 20, 1, 2, 9, 3, 4], this would give us the following strings letterOne would be [\u0026quot;pqrst\u0026quot;], letterTwo would be [\u0026quot;tuvwx\u0026quot;]\u0026hellip; and letterSeven would be [\u0026quot;defgh\u0026quot;].\nNow we can overrite the letterOne-letterSeven variables with the string from the letterNumber dictionary, corresponding to that number. Next, we can split up the five letters in each string by breaking them up by location in the string (position 0-4).\nletterOne = letterNumber[letterOne]\rletterTwo = letterNumber[letterTwo]\rletterThree = letterNumber[letterThree]\rletterFour = letterNumber[letterFour]\rletterFive = letterNumber[letterFive]\rletterSix = letterNumber[letterSix]\rletterSeven = letterNumber[letterSeven]\rletterOne = letterOne[0], letterOne[1], letterOne[2], letterOne[3], letterOne[4]\rletterTwo = letterTwo[0], letterTwo[1], letterTwo[2], letterTwo[3], letterTwo[4]\rletterThree = letterThree[0], letterThree[1], letterThree[2], letterThree[3], letterThree[4]\rletterFour = letterFour[0], letterFour[1], letterFour[2], letterFour[3], letterFour[4]\rletterFive = letterFive[0], letterFive[1], letterFive[2], letterFive[3], letterFive[4]\rletterSix = letterSix[0], letterSix[1], letterSix[2], letterSix[3], letterSix[4]\rletterSeven = letterSeven[0], letterSeven[1], letterSeven[2], letterSeven[3], letterSeven[4]\r Now we can start using the itertools product() iterator to find the cartesian product of letterOne to letterSeven. We will then use the more-itertools sliced() to seperate the extremely long return (should be over 78,000 iterations) of letters into sets of 7.\nwordList = []\rcounter = 0\rresult = itertools.product(letterOne, letterTwo, letterThree, letterFour, letterFive, letterSix, letterSeven)\rfor each in result:\rwordList += list(each)\rcounter +=1\rwordList = (list(sliced(wordList, 7)))\r For troubleshooting, we could use the following code to print out ALL 78,000+ possibilities (simply click at any point to freeze the strings displayed):\nprint('My list:', *wordList, sep='\\n')\r Finally, we can check each of the strings against the enchant english dictionary.\nres = [''.join(ele) for ele in wordList] english_words = []\rfor word in res:\rif d.check(word):\renglish_words.append(word)\renglish_wordsLength = len(english_words)\rprint(f\u0026quot;{english_wordsLength} possible answer(s):\u0026quot;)\rfor l in english_words:\rprint(l[0:])\r This will check all strings against the enchant english dictionary and append any words that have a return of True to the english_words list. We then print the number of possible answers and each individual string!\nIf we used the numbers given with the clue at the beginning of this post, we should have the following output:\n[16, 20, 1, 2, 9, 3, 4]\rNumber of iterations: 78125\r7 possible answer(s):\rpuddled\rquacked\rruddled\rstabled\rstacked\rsteeled\rswacked\r Which one is the past tense of an animal sound?\nConclusion I learned quite a bit from this little program, mainly how important it is to find helpful Python packages! Utilizing both StackOverflow and PyPi to find helpful tools/code is extremely helpful.\nThe following is the complete code for the puzzle solver:\nimport itertools\rfrom itertools import *\rfrom more_itertools import *\rimport enchant\rd = enchant.Dict(\u0026quot;en_US\u0026quot;)\rimport math\rletters = [15, 5, 15, 15, 5, 15, 10]\rmaxLength = 7\rwhile len(letters) \u0026lt; maxLength:\rletter = int(input(\u0026quot;Please input number: \u0026quot;))\rif letter \u0026lt; 0 or letter \u0026gt; 26:\rprint(\u0026quot;Invalid number!\u0026quot;)\rbreak\rletters.append(letter)\rprint(letters)\rletterOne = letters[0]\rletterTwo = letters[1]\rletterThree = letters[2]\rletterFour = letters[3]\rletterFive = letters[4]\rletterSix = letters[5]\rletterSeven = letters[6]\rletterNumber = {\r0 : \u0026quot;/abcd\u0026quot;,\r1 : \u0026quot;abcde\u0026quot;, 2 : \u0026quot;bcdef\u0026quot;, 3 : \u0026quot;cdefg\u0026quot;,\r4 : \u0026quot;defgh\u0026quot;,\r5 : \u0026quot;efghi\u0026quot;,\r6 : \u0026quot;fghij\u0026quot;,\r7 : \u0026quot;ghijk\u0026quot;,\r8 : \u0026quot;hijkl\u0026quot;,\r9 : \u0026quot;ijklm\u0026quot;,\r10 : \u0026quot;jklmn\u0026quot;,\r11 : \u0026quot;klmno\u0026quot;,\r12 : \u0026quot;lmnop\u0026quot;,\r13 : \u0026quot;mnopq\u0026quot;,\r14 : \u0026quot;nopqr\u0026quot;,\r15 : \u0026quot;opqrs\u0026quot;,\r16 : \u0026quot;pqrst\u0026quot;,\r17 : \u0026quot;qrstu\u0026quot;,\r18 : \u0026quot;rstuv\u0026quot;,\r19 : \u0026quot;stuvw\u0026quot;,\r20 : \u0026quot;tuvwx\u0026quot;,\r21 : \u0026quot;uvwxy\u0026quot;,\r22 : \u0026quot;vwxyz\u0026quot;,\r23 : \u0026quot;wxyzz\u0026quot;,\r24 : \u0026quot;xyzzz\u0026quot;,\r25 : \u0026quot;yzzzz\u0026quot;,\r26 : \u0026quot;zzzzz\u0026quot;\r}\rletterOne = letterNumber[letterOne]\rletterTwo = letterNumber[letterTwo]\rletterThree = letterNumber[letterThree]\rletterFour = letterNumber[letterFour]\rletterFive = letterNumber[letterFive]\rletterSix = letterNumber[letterSix]\rletterSeven = letterNumber[letterSeven]\rletterOne = letterOne[0], letterOne[1], letterOne[2], letterOne[3], letterOne[4]\rletterTwo = letterTwo[0], letterTwo[1], letterTwo[2], letterTwo[3], letterTwo[4]\rletterThree = letterThree[0], letterThree[1], letterThree[2], letterThree[3], letterThree[4]\rletterFour = letterFour[0], letterFour[1], letterFour[2], letterFour[3], letterFour[4]\rletterFive = letterFive[0], letterFive[1], letterFive[2], letterFive[3], letterFive[4]\rletterSix = letterSix[0], letterSix[1], letterSix[2], letterSix[3], letterSix[4]\rletterSeven = letterSeven[0], letterSeven[1], letterSeven[2], letterSeven[3], letterSeven[4]\rwordList = []\rcounter = 0\rresult = itertools.product(letterOne, letterTwo, letterThree, letterFour, letterFive, letterSix, letterSeven)\rfor each in result:\rwordList += list(each)\rcounter +=1\rwordList = (list(sliced(wordList, 7)))\r#print('My list:', *wordList, sep='\\n') #only needed for troubleshooting\rprint(f\u0026quot;Number of iterations: {counter:n}\u0026quot;)\rres = [''.join(ele) for ele in wordList] english_words = []\rfor word in res:\rif d.check(word):\renglish_words.append(word)\renglish_wordsLength = len(english_words)\rprint(f\u0026quot;{english_wordsLength} possible answer(s):\u0026quot;)\rfor l in english_words:\rprint(l[0:])\r","date":"2021-02-04","permalink":"https://blog.nicklyss.com/post/pythonpuzz/","tags":["python"],"title":"Python Word Puzzle Solver"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;â€”\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\nâ€” Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    InlineÂ  MarkdownÂ  InÂ  Table     italics bold strikethroughÂ  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements â€” abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","date":"2020-05-11","permalink":"https://blog.nicklyss.com/post/markdown-syntax/","tags":["markdown","css","html","themes"],"title":"Markdown Syntax"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your siteâ€™s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n:s ee_no_evil:[Remove the space] ðŸ™ˆ :h ear_no_evil:[Remove the space] ðŸ™‰ :s peak_no_evil:[Remove the space] ðŸ™Š\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji {\rfont-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols;\r}\r","date":"2019-03-05","permalink":"https://blog.nicklyss.com/post/emoji-support/","tags":["emoji"],"title":"Emoji Support"}]